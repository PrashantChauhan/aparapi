package detection;

/**
This project is based on the open source jviolajones project created by Simon
Houllier and is used with his permission. Simon's jviolajones project offers 
a pure Java implementation of the Viola-Jones algorithm.

http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework

The original Java source code for jviolajones can be found here
http://code.google.com/p/jviolajones/ and is subject to the
gnu lesser public license  http://www.gnu.org/licenses/lgpl.html

Many thanks to Simon for his excellent project and for permission to use it 
as the basis of an Aparapi example.
**/

import java.awt.Point;
import java.io.File;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;

public class HaarCascade{

   private static class Stage{
      final int id;

      final List<Tree> trees = new ArrayList<Tree>();

      final float threshold;

      public Stage(int _id, float _threshold) {
         id = _id;
         threshold = _threshold;
      }

      public void addTree(Tree t) {
         trees.add(t);
      }
   }

   private static class Tree{
      final int id;

      final Stage stage;

      final List<Feature> features = new ArrayList<Feature>();

      public Tree(int _id, Stage _stage) {
         id = _id;
         stage = _stage;
      }

      public void addFeature(Feature f) {
         features.add(f);
      }
   }

   private static class Feature{

      final int id;

      final List<Rect> rects = new ArrayList<Rect>();

      final int nb_rects;

      final float threshold;

      final float left_val;

      final float right_val;

      final Point size;

      final int left_node;

      final int right_node;

      final boolean has_left_val;

      final boolean has_right_val;

      final Tree tree;

      public Feature(int _id, Tree _tree, float _threshold, float _left_val, int _left_node, boolean _has_left_val,
            float _right_val, int _right_node, boolean _has_right_val, Point _size) {
         id = _id;
         tree = _tree;
         nb_rects = 0;

         threshold = _threshold;
         left_val = _left_val;
         left_node = _left_node;
         has_left_val = _has_left_val;
         right_val = _right_val;
         right_node = _right_node;
         has_right_val = _has_right_val;
         size = _size;
      }

      public void add(Rect r) {
         rects.add(r);
      }

   }

   private static class Rect{
      final int id; // we use this to access from global parallel arrays

      final int x1, x2, y1, y2;

      final float weight;

      public Rect(int _id, int _x1, int _x2, int _y1, int _y2, float _weight) {
         id = _id;
         x1 = _x1;
         x2 = _x2;
         y1 = _y1;
         y2 = _y2;
         weight = _weight;
      }
   }

   private final static List<Feature> feature_instances = new ArrayList<Feature>();

   final static int FEATURE_INTS = 5;

   final static int FEATURE_FLOATS = 3;

   static int[] feature_r1r2r3LnRn;

   static float[] feature_LvRvThres;

   static int feature_ids;

   final static int RECT_INTS = 4;

   final static int RECT_FLOATS = 1;

   private final static List<Rect> rect_instances = new ArrayList<Rect>();

   static int rect_x1y1x2y2[];

   static float rect_w[];

   static int rect_ids;

   private final static List<Stage> stage_instances = new ArrayList<Stage>();

   final static int STAGE_INTS = 2;

   final static int STAGE_FLOATS = 1;

   static int stage_ids;

   static int stage_startEnd[];

   static float stage_thresh[];

   private final static List<Tree> tree_instances = new ArrayList<Tree>();

   final static int TREE_INTS = 2;

   static int tree_ids;

   static int tree_startEnd[];

   /** The list of classifiers that the test image should pass to be considered as an image.*/
   int[] stageIds;

   Point size;

   /**Factory method. Builds a detector from an XML file.
    * @param filename The XML file (generated by OpenCV) describing the Haar Cascade.
    * @return The corresponding detector.
    */
   public static HaarCascade create(String filename) {

      org.jdom.Document document = null;
      SAXBuilder sxb = new SAXBuilder();
      try {
         document = sxb.build(new File(filename));
      } catch (Exception e) {
         e.printStackTrace();
      }

      return new HaarCascade(document);

   }

   /** Detector constructor.
    * Builds, from a XML document (i.e. the result of parsing an XML file, the corresponding Haar cascade.
    * @param document The XML document (parsing of file generated by OpenCV) describing the Haar cascade.
    * 
    * http://code.google.com/p/jjil/wiki/ImplementingHaarCascade
    */

   /** Detector constructor.
    * Builds, from a XML document (i.e. the result of parsing an XML file, the corresponding Haar cascade.
    * @param document The XML document (parsing of file generated by OpenCV) describing the Haar cascade.
    * 
    * http://code.google.com/p/jjil/wiki/ImplementingHaarCascade
    */
   public HaarCascade(Document document) {

      List<Stage> stageList = new LinkedList<Stage>();
      Element racine = (Element) document.getRootElement().getChildren().get(0);
      Scanner scanner = new Scanner(racine.getChild("size").getText());
      size = new Point(scanner.nextInt(), scanner.nextInt());
      Iterator it = racine.getChild("stages").getChildren("_").iterator();
      while (it.hasNext()) {
         Element stage = (Element) it.next();
         float thres = Float.parseFloat(stage.getChild("stage_threshold").getText());
         //System.out.println(thres);
         Iterator it2 = stage.getChild("trees").getChildren("_").iterator();
         Stage st = new Stage(HaarCascade.stage_ids++, thres);

         HaarCascade.stage_instances.add(st);

         System.out.println("create stage " + thres);
         while (it2.hasNext()) {
            Element tree = ((Element) it2.next());
            Tree t = new Tree(HaarCascade.tree_ids++, st);

            HaarCascade.tree_instances.add(t);
            Iterator it4 = tree.getChildren("_").iterator();
            while (it4.hasNext()) {
               Element feature = (Element) it4.next();
               float thres2 = Float.parseFloat(feature.getChild("threshold").getText());
               int left_node = -1;
               float left_val = 0;
               boolean has_left_val = false;
               int right_node = -1;
               float right_val = 0;
               boolean has_right_val = false;
               Element e;
               if ((e = feature.getChild("left_val")) != null) {
                  left_val = Float.parseFloat(e.getText());
                  has_left_val = true;
               } else {
                  left_node = Integer.parseInt(feature.getChild("left_node").getText());
                  has_left_val = false;
               }

               if ((e = feature.getChild("right_val")) != null) {
                  right_val = Float.parseFloat(e.getText());
                  has_right_val = true;
               } else {
                  right_node = Integer.parseInt(feature.getChild("right_node").getText());
                  has_right_val = false;
               }
               Feature f = new Feature(HaarCascade.feature_ids++, t, thres2, left_val, left_node, has_left_val, right_val, right_node,
                     has_right_val, size);
               HaarCascade.feature_instances.add(f);
               Iterator it3 = feature.getChild("feature").getChild("rects").getChildren("_").iterator();
               while (it3.hasNext()) {
                  String s = ((Element) it3.next()).getText().trim();
                  //System.out.println(s);

                  String[] tab = s.split(" ");
                  int x1 = Integer.parseInt(tab[0]);
                  int x2 = Integer.parseInt(tab[1]);
                  int y1 = Integer.parseInt(tab[2]);
                  int y2 = Integer.parseInt(tab[3]);
                  float w = Float.parseFloat(tab[4]);

                  Rect r = new Rect(rect_ids++, x1, x2, y1, y2, w);
                  HaarCascade.rect_instances.add(r);
                  f.add(r);

               }

               t.addFeature(f);

            }
            st.addTree(t);

            // System.out.println("Number of nodes in tree " + t.features.size());
         }
         // System.out.println("Number of trees : " + st.trees.size());
         stageList.add(st);

      }

      // now we take the above generated data structure apart and create a data parallel friendly form. 

      stageIds = new int[stageList.size()];
      for (int i = 0; i < stageIds.length; i++) {
         stageIds[i] = stageList.get(i).id;
      }

      HaarCascade.rect_x1y1x2y2 = new int[HaarCascade.rect_ids * HaarCascade.RECT_INTS];
      HaarCascade.rect_w = new float[HaarCascade.rect_ids * HaarCascade.RECT_FLOATS];
      for (int i = 0; i < HaarCascade.rect_ids; i++) {
         Rect r = HaarCascade.rect_instances.get(i);
         HaarCascade.rect_w[i * HaarCascade.RECT_FLOATS + 0] = r.weight;
         HaarCascade.rect_x1y1x2y2[i * HaarCascade.RECT_INTS + 0] = r.x1;
         HaarCascade.rect_x1y1x2y2[i * HaarCascade.RECT_INTS + 1] = r.y1;
         HaarCascade.rect_x1y1x2y2[i * HaarCascade.RECT_INTS + 2] = r.x2;
         HaarCascade.rect_x1y1x2y2[i * HaarCascade.RECT_INTS + 3] = r.y2;
      }

      HaarCascade.feature_r1r2r3LnRn = new int[HaarCascade.feature_ids * HaarCascade.FEATURE_INTS];
      HaarCascade.feature_LvRvThres = new float[HaarCascade.feature_ids * HaarCascade.FEATURE_FLOATS];
      for (int i = 0; i < HaarCascade.feature_ids; i++) {
         Feature f = HaarCascade.feature_instances.get(i);
         HaarCascade.feature_LvRvThres[i * HaarCascade.FEATURE_FLOATS + 0] = f.left_val;
         HaarCascade.feature_LvRvThres[i * HaarCascade.FEATURE_FLOATS + 1] = f.right_val;
         HaarCascade.feature_LvRvThres[i * HaarCascade.FEATURE_FLOATS + 2] = f.threshold;
         HaarCascade.feature_r1r2r3LnRn[i * HaarCascade.FEATURE_INTS + 0] = (f.rects.size() > 0) ? f.rects.get(0).id : -1;
         HaarCascade.feature_r1r2r3LnRn[i * HaarCascade.FEATURE_INTS + 1] = (f.rects.size() > 1) ? f.rects.get(1).id : -1;
         HaarCascade.feature_r1r2r3LnRn[i * HaarCascade.FEATURE_INTS + 2] = (f.rects.size() > 2) ? f.rects.get(2).id : -1;
         HaarCascade.feature_r1r2r3LnRn[i * HaarCascade.FEATURE_INTS + 3] = (f.has_left_val) ? -1 : f.tree.features.get(f.left_node).id;
         HaarCascade.feature_r1r2r3LnRn[i * HaarCascade.FEATURE_INTS + 4] = (f.has_right_val) ? -1 : f.tree.features.get(f.right_node).id;
      }

      HaarCascade.tree_startEnd = new int[HaarCascade.tree_ids * HaarCascade.TREE_INTS];

      for (int i = 0; i < HaarCascade.tree_ids; i++) {
         Tree t = HaarCascade.tree_instances.get(i);
         HaarCascade.tree_startEnd[i * HaarCascade.TREE_INTS + 0] = t.features.get(0).id;
         HaarCascade.tree_startEnd[i * HaarCascade.TREE_INTS + 1] = t.features.get(t.features.size() - 1).id;
      }

      HaarCascade.stage_startEnd = new int[HaarCascade.stage_ids * HaarCascade.STAGE_INTS];
      HaarCascade.stage_thresh = new float[HaarCascade.stage_ids * HaarCascade.STAGE_FLOATS];
      for (int i = 0; i < HaarCascade.stage_ids; i++) {
         Stage t = HaarCascade.stage_instances.get(i);
         HaarCascade.stage_startEnd[i * HaarCascade.STAGE_INTS + 0] = t.trees.get(0).id;
         HaarCascade.stage_startEnd[i * HaarCascade.STAGE_INTS + 1] = t.trees.get(t.trees.size() - 1).id;
         HaarCascade.stage_thresh[i * HaarCascade.STAGE_FLOATS + 0] = t.threshold;
      }

   }

  

  
}
